% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HF_fsusie2.R
\name{HF_susiF2}
\alias{HF_susiF2}
\title{Sum of Single Function (SuSiF)}
\usage{
HF_susiF2(
  Y,
  Z,
  X,
  L = 3,
  nugget = TRUE,
  L_start = 3,
  reflect = FALSE,
  verbose = TRUE,
  n_gh = 10,
  init_b_pm,
  tol = 0.001,
  tol_vga_pois = 1e-05,
  maxit = 10,
  control_mixsqp = list(verbose = FALSE, eps = 1e-06, numiter.em = 4),
  thresh_lowcount = 0,
  gridmult = sqrt(2),
  nullweight.mrash = 10,
  init_pi0_w.mrash = 10,
  cov_lev = 0.95,
  min_purity = 0.5,
  greedy = TRUE,
  backfit = TRUE,
  tol.mrash = 0.001,
  verbose.mrash = TRUE,
  maxit.mrash = 10,
  cal_obj.mrash = FALSE,
  maxit.fsusie = 50,
  cal_obj.fsusie = FALSE,
  max_SNP_EM = 100,
  max_step_EM = 1,
  cor_small = TRUE,
  post_processing = "HMM"
)
}
\arguments{
\item{Y}{A matrix of size N by J representing the functional phenotype. The algorithm assumes that J is a power of 2. If J is not a power of 2, SuSiF internally remaps the data to a grid of length 2^J.}

\item{Z}{A matrix of covariates. Details were not provided in the original documentation, please add relevant details.}

\item{X}{A matrix of size N by P containing the covariates.}

\item{L}{An upper bound on the number of effects to fit. Defaults to 2 if not specified.}

\item{nugget}{Logical, if `TRUE`, the nugget effect is included in the model. Defaults to `TRUE`.}

\item{L_start}{The number of effects initialized at the start of the algorithm. Defaults to 3.}

\item{reflect}{Logical, if `TRUE`, reflection of the data is performed. Defaults to `FALSE`.}

\item{verbose}{Logical, if `TRUE`, the function prints progress information. Defaults to `TRUE`.}

\item{n_gh}{Number of Gauss-Hermite quadrature points. Defaults to 10.}

\item{init_b_pm}{Initial values for the posterior mean of the coefficients. This parameter needs to be documented.}

\item{tol}{A small, non-negative number specifying the convergence tolerance for the fitting procedure. Defaults to 1e-3.}

\item{tol_vga_pois}{Convergence tolerance for the variational Gaussian approximation (VGA) for Poisson distribution. Defaults to 1e-5.}

\item{maxit}{Maximum number of iterations for the fitting procedure. Defaults to 10.}

\item{control_mixsqp}{A list of control parameters for the `mixsqp` function. Defaults are provided.}

\item{thresh_lowcount}{A numeric threshold for handling wavelet coefficients with problematic distributions. Defaults to 0.}

\item{gridmult}{A numeric value used to control the number of components in the mixture prior. Defaults to `sqrt(2)`.}

\item{nullweight.mrash}{A numeric value for penalizing likelihood at point mass 0 in the `mrash` method. Defaults to 10.}

\item{init_pi0_w.mrash}{Initial weight on the null component in the `mrash` method. Defaults to 10.}

\item{cov_lev}{A numeric value between 0 and 1 for the expected level of coverage of credible sets. Defaults to 0.95.}

\item{min_purity}{Minimum purity for estimated credible sets. Defaults to 0.5.}

\item{greedy}{Logical, if `TRUE`, allows for a greedy search for extra effects. Defaults to `TRUE`.}

\item{backfit}{Logical, if `TRUE`, allows discarding effects via backfitting. Defaults to `TRUE`.}

\item{tol.mrash}{Convergence tolerance for the `mrash` method. Defaults to 1e-3.}

\item{verbose.mrash}{Logical, if `TRUE`, prints progress information for the `mrash` method. Defaults to `TRUE`.}

\item{maxit.mrash}{Maximum number of iterations for the `mrash` method. Defaults to 10.}

\item{cal_obj.mrash}{Logical, if `TRUE`, computes ELBO for `mrash`. Defaults to `FALSE`.}

\item{maxit.fsusie}{Maximum number of iterations for the `fsusie` method. Defaults to 50.}

\item{cal_obj.fsusie}{Logical, if `TRUE`, computes ELBO for `fsusie`. Defaults to `FALSE`.}

\item{max_SNP_EM}{Maximum number of SNPs considered in the EM algorithm. Defaults to 100.}

\item{max_step_EM}{Maximum number of steps in the EM algorithm. Defaults to 1.}

\item{cor_small}{Logical, if `TRUE`, corrects for small values in the correlation matrix. Defaults to `TRUE`.}

\item{post_processing}{Specifies the post-processing method. Defaults to "HMM".}
}
\value{
The function returns a list containing the SuSiF results and related components.
}
\description{
This function implements the SuSiF method for analyzing functional phenotypes using wavelet-based techniques.
}
\details{
The SuSiF method is designed to work with functional phenotypes, where the underlying algorithm employs wavelets. This function accommodates various parameters for fine-tuning the analysis, such as specifying priors, convergence tolerance, and effect-fitting bounds.
}
\examples{
library(ashr)
library(wavethresh)
set.seed(1)
# Example using curves simulated under the Mixture Normal Per Scale prior
rsnr <- 0.2 # Expected root signal-to-noise ratio
N <- 100    # Number of individuals
P <- 10     # Number of covariates/SNPs
pos1 <- 1   # Position of the causal covariate for effect 1
pos2 <- 5   # Position of the causal covariate for effect 2
lev_res <- 7 # Length of the molecular phenotype (2^lev_res)
f1 <- simu_IBSS_per_level(lev_res)$sim_func # First effect
f2 <- simu_IBSS_per_level(lev_res)$sim_func # Second effect

plot(f1, type ="l", ylab="effect", col="blue")
abline(a=0, b=0)
lines(f2, type="l", col="green")

legend(x=100, y=3, lty=rep(1,3), legend=c("effect 1", "effect 2"), col=c("black","blue","yellow"))
G <- matrix(sample(c(0, 1, 2), size=N*P, replace=TRUE), nrow=N, ncol=P) # Genotype matrix
beta0 <- 0
beta1 <- 1
beta2 <- 1
noisy.data <- list()

for (i in 1:N) {
  f1_obs <- f1
  f2_obs <- f2
  noise <- rnorm(length(f1), sd=(1/rsnr) * var(f1))
  noisy.data[[i]] <- beta1 * G[i, pos1] * f1_obs + beta2 * G[i, pos2] * f2_obs + noise
}
noisy.data <- do.call(rbind, noisy.data)

plot(noisy.data[1,], type="l", col=(G[1, pos1]*3+1), main="Observed curves\ncolored by the causal effect", ylim=c(-40,40), xlab="")
for (i in 2:N) {
  lines(noisy.data[i,], type="l", col=(G[i, pos1]*3+1))
}
legend(x=0.3, y=-10, lty=rep(1,3), legend=c("0", "1", "2"), col=c("black", "blue", "yellow"))

Y <- noisy.data
X <- G
# Running SuSiF
out <- susiF(Y, X, L=2, prior='mixture_normal_per_scale')
# Visualizing the result
plot_susiF(out)

# Accessing the output of SuSiF directly
par(mfrow=c(1,2))
plot(f1, type="l", main="Estimated effect 1", xlab="")
lines(unlist(out$fitted_func[[1]]), col='blue')
abline(a=0, b=0)
legend(x=35, y=3, lty=rep(1,2), legend=c("effect 1","fSuSiE est"), col=c("black","blue"))
plot(f2, type="l", main="Estimated effect 2", xlab="")
lines(unlist(out$fitted_func[[2]]), col='green')
abline(a=0, b=0)
legend(x=20, y=-1.5, lty=rep(1,2), legend=c("effect 2","fSuSiE est"), col=c("black","green"))
par(mfrow=c(1,1))
plot_susiF(out)

}
