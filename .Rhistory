data(N3finemapping)
X <- N3finemapping$X
genotype <-X[sample(1:nrow(X), size=N),1:100]
idx <- which( apply( genotype,2, var ) <1e-15)
if( length(idx)==0){
X <-genotype
Rtrue <- cor (genotype )
}else{
genotype <- genotype [, -idx]
X <-genotype
}
G<- genotype
X <- (X -0.99*min(X))/(0.5*max(X ))
G <-  (G -0.99*min(G ))/(0.5*max(G ))
tpos <- sample(1:ncol(genotype), replace = FALSE,size=2)
true_pos <- tpos
pos1 <- tpos[1]
pos2 <- tpos[2]
if( length(which(apply(G,2,var)==0))>0){
G <- G[,-which(apply(G,2,var)==0)]
}
# G <- matrix( rnorm(nrow(genotype)*300), nrow = nrow(genotype))
predictor <-rep (0, length(lf[[1]] ))
count.data  <- list()
G[ , true_pos[1]] <-G[ , true_pos[1]] -min(G[ , true_pos[1]] )
G[ , true_pos[2]] <-G[ , true_pos[2]] -min(G[ , true_pos[2]] )
for ( i in 1:N)
{
predictor <-rep (0, length(lf[[1]] ))
for ( l in 1:L){
predictor <-predictor + G[i, true_pos[l]]*lf[[l]]+0.3
}
predictor <- exp( predictor + rnorm(  length(lf[[1]]), sd=mysd))
count.data [[i]] <-   rpois(n= length(lf[[1]]) ,
lambda =predictor  )
}
count.data <- do.call(rbind, count.data)
Y <- count.data
res3<-  acc_Pois_fSuSiE2 (Y=Y,X=X, L=3 , post_processing = "HMM")
res3$susiF.obj$cs
lf1_fit[[o]] <-  exp( res3$susiF.obj$fitted_func[[1]]  )-1
lf2_fit[[o]] <-  exp( res3$susiF.obj$fitted_func[[2]]  )-1
}
lf1_out <- do.call(rbind, lf1_fit)
lf2_out <- do.call(rbind, lf2_fit)
lf_out = lf1_out + lf2_out
lf_out = log(lf_out+1)
plot(lf[[1]]+lf[[2]], ylim= c( -0.2, 12) , col="red")
lines(apply(lf_out, 2, mean) +0.1, col="blue")
for (o in 1: length(lf1_fit)){
lines (lf1_fit[[o]], col="blue")
}
true_pos
plot(lf[[2]], ylim= c( -0.2, 5) , col="red")
for (o in 1: length(lf2_fit)){
lines (lf2_fit[[o]], col="blue")
}
lines(apply(lf_out, 2, mean) +0.1, col="blue")
plot(lf[[1]]+lf[[2]], ylim= c( -0.2, 12) , col="red")
lines(apply(lf_out, 2, mean) +0.1, col="blue")
o
rm(list = ls())
library(mvPoisVA)
library(fsusieR)
library(susieR)
library(ebnm)
lf1_fit <-  list()
lf2_fit <-  list()
for (o in 1:400){
print(o)
data(N3finemapping)
X <- N3finemapping$X
mysd=0.5
N =200
genotype <-X[1:N,1:100]
idx <- which( apply( genotype,2, var ) <1e-15)
genotype <- scale( genotype [, -idx])
lev_res =6
count.data  <- list()
L <-2# sample(1:2, size =1)#actual number of effect
lf <-  list()
lf[[1]]<- rep(0.1, 2^6)
lf[[1]][10:20] <-5
lf[[2]]<- rep(0.1, 2^6)
lf[[2]][50:60] <-10
mu= lf[[2]]
x = rpois(length(mu),exp(log(mu)+rnorm(n=length(mu),sd=mysd)))
fit = pois_smooth_split(x,maxiter=30)
plot(x,col='grey80')
lines(exp(fit$Eb))
lines( smashr::smash(haarfisz::hft(x))  , col="green")
lines(lf[[2]])
data(N3finemapping)
X <- N3finemapping$X
genotype <-X[sample(1:nrow(X), size=N),1:100]
idx <- which( apply( genotype,2, var ) <1e-15)
if( length(idx)==0){
X <-genotype
Rtrue <- cor (genotype )
}else{
genotype <- genotype [, -idx]
X <-genotype
}
G<- genotype
X <- (X -0.99*min(X))/(0.5*max(X ))
G <-  (G -0.99*min(G ))/(0.5*max(G ))
tpos <- sample(1:ncol(genotype), replace = FALSE,size=2)
true_pos <- tpos
pos1 <- tpos[1]
pos2 <- tpos[2]
if( length(which(apply(G,2,var)==0))>0){
G <- G[,-which(apply(G,2,var)==0)]
}
# G <- matrix( rnorm(nrow(genotype)*300), nrow = nrow(genotype))
predictor <-rep (0, length(lf[[1]] ))
count.data  <- list()
G[ , true_pos[1]] <-G[ , true_pos[1]] -min(G[ , true_pos[1]] )
G[ , true_pos[2]] <-G[ , true_pos[2]] -min(G[ , true_pos[2]] )
for ( i in 1:N)
{
predictor <-rep (0, length(lf[[1]] ))
for ( l in 1:L){
predictor <-predictor + G[i, true_pos[l]]*lf[[l]]+0.3
}
predictor <- exp( predictor + rnorm(  length(lf[[1]]), sd=mysd))
count.data [[i]] <-   rpois(n= length(lf[[1]]) ,
lambda =predictor  )
}
count.data <- do.call(rbind, count.data)
Y <- count.data
res3<-  acc_Pois_fSuSiE2 (Y=Y,X=X, L=3 , post_processing = "HMM")
res3$susiF.obj$cs
lf1_fit[[o]] <-  exp( res3$susiF.obj$fitted_func[[1]]  )-1
lf2_fit[[o]] <-  exp( res3$susiF.obj$fitted_func[[2]]  )-1
}
lf1_out <- do.call(rbind, lf1_fit)
lf2_out <- do.call(rbind, lf2_fit)
lf_out = lf1_out + lf2_out
lf_out = log(lf_out+1)
plot(lf[[1]]+lf[[2]], ylim= c( -0.2, 12) , col="red")
lines(apply(lf_out, 2, mean) +0.1, col="blue")
for (o in 1: length(lf1_fit)){
lines (lf1_fit[[o]], col="blue")
}
true_pos
plot(lf[[2]], ylim= c( -0.2, 5) , col="red")
for (o in 1: length(lf2_fit)){
lines (lf2_fit[[o]], col="blue")
}
lf1_out <- do.call(rbind, lf1_fit)
lf2_out <- do.call(rbind, lf2_fit)
lf_out = lf1_out + lf2_out
lf_out = log(lf_out+1)
lf_out
plot(lf[[1]]+lf[[2]], ylim= c( -0.2, 12) , col="red")
lines(apply(lf_out, 2, mean) +0.1, col="blue")
for (o in 1: length(lf1_fit)){
lines (lf1_fit[[o]], col="blue")
}
true_pos
plot(lf[[2]], ylim= c( -0.2, 5) , col="red")
for (o in 1: length(lf2_fit)){
lines (lf2_fit[[o]], col="blue")
}
install.packages("haarfisz")
install.packages("fastGHQuad")
install.packages("ebnm")
knitr::opts_chunk$set(echo = TRUE)
library(ashr)
library(wavethresh)
library(susiF.alpha)
library(ashr)
library(wavethresh)
library(fsusieR)
library(mvPoisVA)
set.seed(1)
#Example using curves simulated under the Mixture normal per scale prior
N <- 100    #Number of individuals
P <- 10     #Number of covariates/SNP
pos1 <- 1   #Position of the causal covariate for effect 1
pos2 <- 5   #Position of the causal covariate for effect 2
lev_res <- 7#length of the molecular phenotype (2^lev_res)
f1 <- sim_intenisty(lev_res )$sim_intens[-1]#first effect
f2 <- sim_intenisty(lev_res )$sim_intens[-1]#second effect
plot( f1, type ="l", ylab="effect", col="blue")
abline(a=0,b=0)
lines(f2, type="l", col="green")
G = matrix(sample(c(0, 1,2), size=N*P, replace=TRUE), nrow=N, ncol=P) #Genotype
beta0       <- 0
beta1       <- 1
beta2       <- 1
count.data  <- list()
for ( i in 1:N)
{
predictor <-beta1*G[i,pos1]*f1 + beta2*G[i,pos2]*f2
count.data [[i]] <-   rpois(n= length(f1) ,
lambda =predictor  )
}
count.data <- do.call(rbind, count.data)
Y <-count.data
X <- G
Y_org <- Y
### dealing with non 2^S data ----
J = log2(ncol(Y)); if((J%%1) != 0) reflect=TRUE
if(reflect){
tl <- lapply(1:nrow(Y), function(i) reflect_vec(Y[i,]))
Y <- do.call(rbind, lapply(1:length(tl), function(i) tl[[i]]$x))
idx_out <- tl[[1]]$idx #### indx of interest at the end
}
#### to avoid 0 in Y_min to correct at the end
Y <- Y+1
indx_lst <-  susiF.alpha::gen_wavelet_indx(log2(ncol(Y)))
Y_org <- Y
### dealing with non 2^S data ----
J = log2(ncol(Y)); if((J%%1) != 0) reflect=TRUE
if(reflect){
tl <- lapply(1:nrow(Y), function(i) reflect_vec(Y[i,]))
Y <- do.call(rbind, lapply(1:length(tl), function(i) tl[[i]]$x))
idx_out <- tl[[1]]$idx #### indx of interest at the end
}
#### to avoid 0 in Y_min to correct at the end
Y <- Y+1
indx_lst <-  fsusieR::gen_wavelet_indx(log2(ncol(Y)))
### Wavelet like transform -----
tl <-  lapply(1:nrow(Y), function(i)
get_empirical_intensity(Y[i,],
indx_lst = indx_lst)
)
### Cal Ymin Ytot -----
Y_min <- do.call(rbind, lapply(1:length(tl), function(i) tl[[i]]$Y_min))
Y_tot <- do.call(rbind, lapply(1:length(tl), function(i) tl[[i]]$Y_tot))
rm(tl)
#### parameter of the Kolaciz 1999 transformation
emp_prop <- Y_min[1,]/Y_tot[1,]
emp_log_prop <- log(emp_prop[- length(emp_prop)])
plot(emp_prop, main="empirical proportion, close Normal distribution")
emp_lambda_tot <- Y_tot[1,ncol(Y_tot)]
emp_log_lambda_tot <- log(emp_lambda_tot )
lp <- emp_log_prop
lq = log(1-pmin(exp(lp),1-1e-10))# complementary prop
est <- emp_log_lambda_tot
J=log2(length(Y_min[1,]))
out <- rep( emp_log_lambda_tot, 2^J)
for(s in (J ):1){
#print(exp(est))
#readline("press a key")
nD = 2^(J-s+1)
nDo2 = nD/2
tt <-1
for(l in 0:(2^(s-1)-1)){
ind = (l*nD+1):((l+1)*nD) # all "sub index for coef s,l (here s=D)
# print(ind)
ind_l <-  ind[1:nDo2] #all "sub index in the left for coef s,l (here s=D)
ind_r <-  ind[(nDo2+1):nD] # all "sub index in the right for coef s,l (here s=D)
out[ind_l] <- out[ind_l]+ lp[indx_lst[[(s )]][tt]]
out[ind_r] <- out[ind_r]+ lq[indx_lst[[(s )]][tt]]
tt <- tt+1
}
}
plot( exp(out)[idx_out])
plot(f1[idx_out])
lines(f1)
plot( exp(out)[idx_out])
lines(Y_org[1,])
tt <- reverse_intensity_transform(vec_int = c(emp_prop[-length(emp_prop)] ,
emp_lambda_tot),
indx_lst = indx_lst,
is.logprob = FALSE,
is.log_int = FALSE)
plot( tt)
lines(Y[1,])
knitr::opts_chunk$set(echo = TRUE)
library(mvPoisVA)
library(fsusieR)
library(susieR)
#example from Dongyue Xie work
set.seed(12345)
n=2^9
sigma=0.5
mu=c(rep(0.3,n/4), rep(3, n/4), rep(10, n/4), rep(0.3, n/4))
plot(mu, type="l", main="Underlying intensity")
set.seed(123)
x = rpois(length(mu),exp(log(mu)+rnorm(n=length(mu),sd=sigma)))
plot(mu, type="l", main="Underlying intensity")
fit = pois_smooth_split(x,maxiter=30)
fit_ebps = ebps(x)
fit_pois = pois_mean_split(x)
plot(x,col='grey80')
lines(fit_pois$posterior$mean, col= "magenta", lwd=.5)
lines(fit_ebps$posterior$mean_smooth, col= "orange2", lwd=1.5)
lines(exp(fit$Eb), col= "blue3", lwd=1.5)
lines( smashr::smash(haarfisz::hft(x))  , col="darkgreen", lwd=1.5)
install.packages("devtools")
library(devtools)
install_github("stephenslab/smashr")
install.packages("devtools")
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
x = rpois(length(mu),exp(log(mu)+rnorm(n=length(mu),sd=sigma)))
plot(mu, type="l", main="Underlying intensity")
fit = pois_smooth_split(x,maxiter=30)
devtools::load_all(".")
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
x = rpois(length(mu),exp(log(mu)+rnorm(n=length(mu),sd=sigma)))
plot(mu, type="l", main="Underlying intensity")
fit = pois_smooth_split(x,maxiter=30)
fit_ebps = ebps(x)
fit_pois = pois_mean_split(x)
plot(x,col='grey80')
lines(fit_pois$posterior$mean, col= "magenta", lwd=.5)
lines(fit_ebps$posterior$mean_smooth, col= "orange2", lwd=1.5)
lines(exp(fit$Eb), col= "blue3", lwd=1.5)
lines( smashr::smash(haarfisz::hft(x))  , col="darkgreen", lwd=1.5)
install_github("stephenslab/smashr@v1.2-7")
library(devtools)
install_github("stephenslab/smashr@v1.2-7")
rm(list = ls())
library(mvPoisVA)
library(susiF.alpha)
set.seed(123)
x = rpois(length(mu),exp(log(mu)+rnorm(n=length(mu),sd=sigma)))
knitr::opts_chunk$set(echo = TRUE)
library(mvPoisVA)
library(fsusieR)
library(susieR)
#example from Dongyue Xie work
set.seed(12345)
n=2^9
sigma=0.5
mu=c(rep(0.3,n/4), rep(3, n/4), rep(10, n/4), rep(0.3, n/4))
plot(mu, type="l", main="Underlying intensity")
set.seed(123)
x = rpois(length(mu),exp(log(mu)+rnorm(n=length(mu),sd=sigma)))
plot(mu, type="l", main="Underlying intensity")
fit = pois_smooth_split(x,maxiter=30)
rm(list = ls())
library(mvPoisVA)
library(fsusieR)
library(susieR)
library(ebnm)
set.seed(1)
'%!in%' <- function(x,y)!('%in%'(x,y))
data(N3finemapping)
X <- N3finemapping$X
mysd=2
N =70
genotype <-X[1:N,1:100]
data(N3finemapping)
X <- N3finemapping$X
genotype <-X[sample(1:nrow(X), size=N),1:100]
idx <- which( apply( genotype,2, var ) <1e-15)
if( length(idx)==0){
X <-genotype
Rtrue <- cor (genotype )
}else{
genotype <- genotype [, -idx]
X <-genotype
}
G<- genotype
X <- (X -0.99*min(X))/(0.5*max(X ))
G <-  (G -0.99*min(G ))/(0.5*max(G ))
idx <- which( apply( genotype,2, var ) <1e-15)
if ( length(idx)>0){
genotype <- genotype [, -idx]
}
lev_res =6
count.data  <- list()
L <-2# sample(1:2, size =1)#actual number of effect
lf <-  list()
lf[[1]]<- rep(0.1, 2^6)
lf[[1]][10:20] <-2
lf[[2]]<- rep(0.1, 2^6)
lf[[2]][50:60] <-2
true_pos <- sample(1:ncol(genotype), replace = FALSE,size=2)
plot (lf[[1]], type="l", main=paste ( "effect of SNP",true_pos[1]))
plot (lf[[2]], type="l", main=paste ( "effect of SNP",true_pos[2]))
pos1 <- true_pos[1]
pos2 <- true_pos[2]
if( length(which(apply(G,2,var)==0))>0){
G <- G[,-which(apply(G,2,var)==0)]
}
# G <- matrix( rnorm(nrow(genotype)*300), nrow = nrow(genotype))
predictor <-rep (0, length(lf[[1]] ))
count.data  <- list()
G[ , true_pos[1]] <-G[ , true_pos[1]] -min(G[ , true_pos[1]] )
G[ , true_pos[2]] <-G[ , true_pos[2]] -min(G[ , true_pos[2]] )
for ( i in 1:N)
{
predictor <-rep (0, length(lf[[1]] ))
for ( l in 1:L){
predictor <-predictor + G[i, true_pos[l]]*lf[[l]]+0.3
}
predictor <- exp( predictor+ rnorm(  length(lf[[1]]), sd=mysd))
count.data [[i]] <-   rpois(n= length(lf[[1]]) ,
lambda =predictor  )
}
count.data <- do.call(rbind, count.data)
Y <- count.data
res01 <-acc_Pois_fSuSiE2 (Y=Y,X=X, L=3 , post_processing = "HMM")
res01$susiF.obj$cs
plot ( exp( res01$susiF.obj$fitted_func[[2]]  )-1, type="l", main=paste ( "effect of SNP",true_pos[2]), col= "green4")
res01$susiF.obj$cs
res01$susiF.obj$fitted_func
lot (exp( res01$susiF.obj$fitted_func[[1]]  )-1 , type="l", main=paste ( "effect of SNP",true_pos[2]), col= "green4")
plot (exp( res01$susiF.obj$fitted_func[[1]]  )-1 , type="l", main=paste ( "effect of SNP",true_pos[2]), col= "green4")
lines(lf[[2]] )
rm(list = ls())
library(mvPoisVA)
library(fsusieR)
library(susieR)
library(ebnm)
set.seed(1)
'%!in%' <- function(x,y)!('%in%'(x,y))
data(N3finemapping)
X <- N3finemapping$X
mysd=0.5
N =70
genotype <-X[1:N,1:100]
data(N3finemapping)
X <- N3finemapping$X
genotype <-X[sample(1:nrow(X), size=N),1:100]
idx <- which( apply( genotype,2, var ) <1e-15)
if( length(idx)==0){
X <-genotype
Rtrue <- cor (genotype )
}else{
genotype <- genotype [, -idx]
X <-genotype
}
G<- genotype
X <- (X -0.99*min(X))/(0.5*max(X ))
G <-  (G -0.99*min(G ))/(0.5*max(G ))
rm(list = ls())
library(mvPoisVA)
library(fsusieR)
library(susieR)
library(ebnm)
set.seed(1)
'%!in%' <- function(x,y)!('%in%'(x,y))
data(N3finemapping)
X <- N3finemapping$X
mysd=0.5
N =70
genotype <-X[1:N,1:100]
data(N3finemapping)
X <- N3finemapping$X
genotype <-X[sample(1:nrow(X), size=N),1:100]
idx <- which( apply( genotype,2, var ) <1e-15)
if( length(idx)==0){
X <-genotype
Rtrue <- cor (genotype )
}else{
genotype <- genotype [, -idx]
X <-genotype
}
G<- genotype
X <- (X -0.99*min(X))/(0.5*max(X ))
G <-  (G -0.99*min(G ))/(0.5*max(G ))
idx <- which( apply( genotype,2, var ) <1e-15)
if ( length(idx)>0){
genotype <- genotype [, -idx]
}
lev_res =6
count.data  <- list()
L <-2# sample(1:2, size =1)#actual number of effect
lf <-  list()
lf[[1]]<- rep(0.1, 2^6)
lf[[1]][10:20] <-2
lf[[2]]<- rep(0.1, 2^6)
lf[[2]][50:60] <-2
true_pos <- sample(1:ncol(genotype), replace = FALSE,size=2)
plot (lf[[1]], type="l", main=paste ( "effect of SNP",true_pos[1]))
plot (lf[[2]], type="l", main=paste ( "effect of SNP",true_pos[2]))
pos1 <- true_pos[1]
pos2 <- true_pos[2]
if( length(which(apply(G,2,var)==0))>0){
G <- G[,-which(apply(G,2,var)==0)]
}
# G <- matrix( rnorm(nrow(genotype)*300), nrow = nrow(genotype))
predictor <-rep (0, length(lf[[1]] ))
count.data  <- list()
G[ , true_pos[1]] <-G[ , true_pos[1]] -min(G[ , true_pos[1]] )
G[ , true_pos[2]] <-G[ , true_pos[2]] -min(G[ , true_pos[2]] )
for ( i in 1:N)
{
predictor <-rep (0, length(lf[[1]] ))
for ( l in 1:L){
predictor <-predictor + G[i, true_pos[l]]*lf[[l]]+0.3
}
predictor <- exp( predictor+ rnorm(  length(lf[[1]]), sd=mysd))
count.data [[i]] <-   rpois(n= length(lf[[1]]) ,
lambda =predictor  )
}
count.data <- do.call(rbind, count.data)
Y <- count.data
res01 <-acc_Pois_fSuSiE2 (Y=Y,X=X, L=3 , post_processing = "HMM")
res01$susiF.obj$cs
plot ( exp( res01$susiF.obj$fitted_func[[2]]  )-1, type="l", main=paste ( "effect of SNP",true_pos[2]), col= "green4")
lines(lf[[1]])
plot (exp( res01$susiF.obj$fitted_func[[1]]  )-1 , type="l", main=paste ( "effect of SNP",true_pos[2]), col= "green4")
lines(lf[[2]] )
set.seed(123)
x = rpois(length(mu),exp(log(mu)+rnorm(n=length(mu),sd=sigma)))
usethis::use_testthat()
# install.packages('devtools')
## Make sure R package ebnm is installed
# devtools::install_github('stephenslab/ebnm')
devtools::install_github('DongyueXie/vebpm')
library(vebpm)
ebps_int
devtools::load_all(".")
